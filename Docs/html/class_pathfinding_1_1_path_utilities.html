<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Frostcore: Pathfinding.PathUtilities Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Frostcore
   &#160;<span id="projectnumber">0.31a</span>
   </div>
   <div id="projectbrief">2D ARPG SC-FI</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_pathfinding.html">Pathfinding</a></li><li class="navelem"><a class="el" href="class_pathfinding_1_1_path_utilities.html">PathUtilities</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_pathfinding_1_1_path_utilities-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Pathfinding.PathUtilities Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains useful functions for working with paths and nodes.  
 <a href="class_pathfinding_1_1_path_utilities.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7cbd833e92f01ab3ba7cc3464b5885bd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_path_utilities.html#a7cbd833e92f01ab3ba7cc3464b5885bd">IsPathPossible</a> (<a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> n1, <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> n2)</td></tr>
<tr class="memdesc:a7cbd833e92f01ab3ba7cc3464b5885bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if there is a walkable path from <em>n1</em> to <em>n2</em>.  <a href="#a7cbd833e92f01ab3ba7cc3464b5885bd">More...</a><br /></td></tr>
<tr class="separator:a7cbd833e92f01ab3ba7cc3464b5885bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c65409c2f47489c426cf9b9614e78a0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_path_utilities.html#a9c65409c2f47489c426cf9b9614e78a0">IsPathPossible</a> (List&lt; <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> &gt; nodes)</td></tr>
<tr class="memdesc:a9c65409c2f47489c426cf9b9614e78a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if there are walkable paths between all nodes.  <a href="#a9c65409c2f47489c426cf9b9614e78a0">More...</a><br /></td></tr>
<tr class="separator:a9c65409c2f47489c426cf9b9614e78a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9c8e2befb7f0e4fe6dcf399a22c66c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_path_utilities.html#aca9c8e2befb7f0e4fe6dcf399a22c66c">IsPathPossible</a> (List&lt; <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> &gt; nodes, int tagMask)</td></tr>
<tr class="memdesc:aca9c8e2befb7f0e4fe6dcf399a22c66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if there are walkable paths between all nodes.  <a href="#aca9c8e2befb7f0e4fe6dcf399a22c66c">More...</a><br /></td></tr>
<tr class="separator:aca9c8e2befb7f0e4fe6dcf399a22c66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4caaacc4ac4d1c002d59439c94c81b26"><td class="memItemLeft" align="right" valign="top">static List&lt; <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_path_utilities.html#a4caaacc4ac4d1c002d59439c94c81b26">GetReachableNodes</a> (<a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> seed, int tagMask=-1)</td></tr>
<tr class="memdesc:a4caaacc4ac4d1c002d59439c94c81b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all nodes reachable from the seed node.  <a href="#a4caaacc4ac4d1c002d59439c94c81b26">More...</a><br /></td></tr>
<tr class="separator:a4caaacc4ac4d1c002d59439c94c81b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb3d062612ca0a30db9f41b324106d7"><td class="memItemLeft" align="right" valign="top">static List&lt; <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_path_utilities.html#a6fb3d062612ca0a30db9f41b324106d7">BFS</a> (<a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> seed, int depth, int tagMask=-1)</td></tr>
<tr class="memdesc:a6fb3d062612ca0a30db9f41b324106d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all nodes up to a given node-distance from the seed node.  <a href="#a6fb3d062612ca0a30db9f41b324106d7">More...</a><br /></td></tr>
<tr class="separator:a6fb3d062612ca0a30db9f41b324106d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfaf4b4a4759ede29bf06a4d2775263"><td class="memItemLeft" align="right" valign="top">static List&lt; Vector3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_path_utilities.html#a8cfaf4b4a4759ede29bf06a4d2775263">GetSpiralPoints</a> (int count, float clearance)</td></tr>
<tr class="memdesc:a8cfaf4b4a4759ede29bf06a4d2775263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns points in a spiral centered around the origin with a minimum clearance from other points.  <a href="#a8cfaf4b4a4759ede29bf06a4d2775263">More...</a><br /></td></tr>
<tr class="separator:a8cfaf4b4a4759ede29bf06a4d2775263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6dbca938d4f6cf727654e514d690826"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_path_utilities.html#ae6dbca938d4f6cf727654e514d690826">GetPointsAroundPointWorld</a> (Vector3 p, <a class="el" href="interface_pathfinding_1_1_i_raycastable_graph.html">IRaycastableGraph</a> g, List&lt; Vector3 &gt; previousPoints, float radius, float clearanceRadius)</td></tr>
<tr class="memdesc:ae6dbca938d4f6cf727654e514d690826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will calculate a number of points around <em>p</em> which are on the graph and are separated by <em>clearance</em> from each other.  <a href="#ae6dbca938d4f6cf727654e514d690826">More...</a><br /></td></tr>
<tr class="separator:ae6dbca938d4f6cf727654e514d690826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f633ee143fbe17cd5b4e41e743bfa9b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_path_utilities.html#a2f633ee143fbe17cd5b4e41e743bfa9b">GetPointsAroundPoint</a> (Vector3 p, <a class="el" href="interface_pathfinding_1_1_i_raycastable_graph.html">IRaycastableGraph</a> g, List&lt; Vector3 &gt; previousPoints, float radius, float clearanceRadius)</td></tr>
<tr class="memdesc:a2f633ee143fbe17cd5b4e41e743bfa9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will calculate a number of points around <em>p</em> which are on the graph and are separated by <em>clearance</em> from each other.  <a href="#a2f633ee143fbe17cd5b4e41e743bfa9b">More...</a><br /></td></tr>
<tr class="separator:a2f633ee143fbe17cd5b4e41e743bfa9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e63781b73c5eb340c8b6e9fe7927dc"><td class="memItemLeft" align="right" valign="top">static List&lt; Vector3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pathfinding_1_1_path_utilities.html#ad9e63781b73c5eb340c8b6e9fe7927dc">GetPointsOnNodes</a> (List&lt; <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> &gt; nodes, int count, float clearanceRadius=0)</td></tr>
<tr class="memdesc:ad9e63781b73c5eb340c8b6e9fe7927dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns randomly selected points on the specified nodes with each point being separated by <em>clearanceRadius</em> from each other.  <a href="#ad9e63781b73c5eb340c8b6e9fe7927dc">More...</a><br /></td></tr>
<tr class="separator:ad9e63781b73c5eb340c8b6e9fe7927dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains useful functions for working with paths and nodes. </p>
<p>This class works a lot with the Node class, a useful function to get nodes is <a class="el" href="class_astar_path.html#a7d49736e7a25f4cf9fc24bdbec862359" title="Returns the nearest node to a position using the specified NNConstraint. ">AstarPath.GetNearest</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_astar_path.html#a7d49736e7a25f4cf9fc24bdbec862359" title="Returns the nearest node to a position using the specified NNConstraint. ">AstarPath.GetNearest</a> </dd>
<dd>
Pathfinding.Utils.GraphUpdateUtilities </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Added in version 3.2 </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6fb3d062612ca0a30db9f41b324106d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static List&lt;<a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a>&gt; Pathfinding.PathUtilities.BFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a>&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tagMask</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all nodes up to a given node-distance from the seed node. </p>
<p>This function performs a BFS (breadth-first-search) or flood fill of the graph and returns all nodes within a specified node distance which can be reached from the seed node. In almost all cases when <em>depth</em> is large enough this will be identical to returning all nodes which have the same area as the seed node. In the editor areas are displayed as different colors of the nodes. The only case where it will not be so is when there is a one way path from some part of the area to the seed node but no path from the seed node to that part of the graph.</p>
<p>The returned list is sorted by node distance from the seed node i.e distance is measured in the number of nodes the shortest path from <em>seed</em> to that node would pass through. Note that the distance measurement does not take heuristics, penalties or tag penalties.</p>
<p>Depending on the number of nodes, this function can take quite some time to calculate so don't use it too often or it might affect the framerate of your game.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The node to start the search from. </td></tr>
    <tr><td class="paramname">depth</td><td>The maximum node-distance from the seed node. </td></tr>
    <tr><td class="paramname">tagMask</td><td>Optional mask for tags. This is a bitmask.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A List&lt;Node&gt; containing all nodes reachable up to a specified node distance from the seed node. For better memory management the returned list should be pooled, see <a class="el" href="class_pathfinding_1_1_util_1_1_list_pool.html" title="Lightweight List Pool. ">Pathfinding.Util.ListPool</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This method is not thread safe. Only use it from the Unity thread (i.e normal game code). </dd></dl>

</div>
</div>
<a class="anchor" id="a2f633ee143fbe17cd5b4e41e743bfa9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Pathfinding.PathUtilities.GetPointsAroundPoint </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_pathfinding_1_1_i_raycastable_graph.html">IRaycastableGraph</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; Vector3 &gt;&#160;</td>
          <td class="paramname"><em>previousPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearanceRadius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Will calculate a number of points around <em>p</em> which are on the graph and are separated by <em>clearance</em> from each other. </p>
<p>The maximum distance from <em>p</em> to any point will be <em>radius</em>. Points will first be tried to be laid out as <em>previousPoints</em> and if that fails, random points will be selected. This is great if you want to pick a number of target points for group movement. If you pass all current agent points from e.g the group's average position this method will return target points so that the units move very little within the group, this is often aesthetically pleasing and reduces jitter if using some kind of local avoidance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point to generate points around </td></tr>
    <tr><td class="paramname">g</td><td>The graph to use for linecasting. If you are only using one graph, you can get this by AstarPath.active.graphs[0] as <a class="el" href="interface_pathfinding_1_1_i_raycastable_graph.html">IRaycastableGraph</a>. Note that not all graphs are raycastable, recast, navmesh and grid graphs are raycastable. On recast and navmesh it works the best. </td></tr>
    <tr><td class="paramname">previousPoints</td><td>The points to use for reference. Note that these should not be in world space. They are treated as relative to <em>p</em>. </td></tr>
    <tr><td class="paramname">radius</td><td>The final points will be at most this distance from <em>p</em>. </td></tr>
    <tr><td class="paramname">clearanceRadius</td><td>The points will if possible be at least this distance from each other. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6dbca938d4f6cf727654e514d690826"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Pathfinding.PathUtilities.GetPointsAroundPointWorld </td>
          <td>(</td>
          <td class="paramtype">Vector3&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_pathfinding_1_1_i_raycastable_graph.html">IRaycastableGraph</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&lt; Vector3 &gt;&#160;</td>
          <td class="paramname"><em>previousPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearanceRadius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Will calculate a number of points around <em>p</em> which are on the graph and are separated by <em>clearance</em> from each other. </p>
<p>This is like GetPointsAroundPoint except that <em>previousPoints</em> are treated as being in world space. The average of the points will be found and then that will be treated as the group center. </p>

</div>
</div>
<a class="anchor" id="ad9e63781b73c5eb340c8b6e9fe7927dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static List&lt;Vector3&gt; Pathfinding.PathUtilities.GetPointsOnNodes </td>
          <td>(</td>
          <td class="paramtype">List&lt; <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> &gt;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearanceRadius</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns randomly selected points on the specified nodes with each point being separated by <em>clearanceRadius</em> from each other. </p>
<p>Selecting points ON the nodes only works for <a class="el" href="class_pathfinding_1_1_triangle_mesh_node.html" title="Node represented by a triangle. ">TriangleMeshNode</a> (used by Recast Graph and Navmesh Graph) and <a class="el" href="class_pathfinding_1_1_grid_node.html">GridNode</a> (used by <a class="el" href="class_pathfinding_1_1_grid_graph.html" title="Generates a grid of nodes. ">GridGraph</a>). For other node types, only the positions of the nodes will be used.</p>
<p>clearanceRadius will be reduced if no valid points can be found. </p>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000004">Bug:</a></b></dt><dd>Doesn't this need to be divided by 2? </dd></dl>

</div>
</div>
<a class="anchor" id="a4caaacc4ac4d1c002d59439c94c81b26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static List&lt;<a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a>&gt; Pathfinding.PathUtilities.GetReachableNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a>&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tagMask</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all nodes reachable from the seed node. </p>
<p>This function performs a BFS (breadth-first-search) or flood fill of the graph and returns all nodes which can be reached from the seed node. In almost all cases this will be identical to returning all nodes which have the same area as the seed node. In the editor areas are displayed as different colors of the nodes. The only case where it will not be so is when there is a one way path from some part of the area to the seed node but no path from the seed node to that part of the graph.</p>
<p>The returned list is sorted by node distance from the seed node i.e distance is measured in the number of nodes the shortest path from <em>seed</em> to that node would pass through. Note that the distance measurement does not take heuristics, penalties or tag penalties.</p>
<p>Depending on the number of reachable nodes, this function can take quite some time to calculate so don't use it too often or it might affect the framerate of your game.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The node to start the search from </td></tr>
    <tr><td class="paramname">tagMask</td><td>Optional mask for tags. This is a bitmask.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A List&lt;Node&gt; containing all nodes reachable from the seed node. For better memory management the returned list should be pooled, see <a class="el" href="class_pathfinding_1_1_util_1_1_list_pool.html" title="Lightweight List Pool. ">Pathfinding.Util.ListPool</a> </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000023">Todo:</a></b></dt><dd>Pool </dd></dl>

</div>
</div>
<a class="anchor" id="a8cfaf4b4a4759ede29bf06a4d2775263"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static List&lt;Vector3&gt; Pathfinding.PathUtilities.GetSpiralPoints </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>clearance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns points in a spiral centered around the origin with a minimum clearance from other points. </p>
<p>The points are laid out on the involute of a circle </p><dl class="section see"><dt>See also</dt><dd><a href="http://en.wikipedia.org/wiki/Involute">http://en.wikipedia.org/wiki/Involute</a> Which has some nice properties. <a class="el" href="namespace_pathfinding.html#ac7f12641e21a7a14f0fac8170a9104fcab1c94ca2fbc3e78fc30069c8d0f01680" title="All bits set to 1. ">All</a> points are separated by <em>clearance</em> world units. This method is O(n), yes if you read the code you will see a binary search, but that binary search has an upper bound on the number of steps, so it does not yield a log factor.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Consider recycling the list after usage to reduce allocations. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_pathfinding_1_1_util_1_1_list_pool.html" title="Lightweight List Pool. ">Pathfinding.Util.ListPool</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7cbd833e92f01ab3ba7cc3464b5885bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.PathUtilities.IsPathPossible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a>&#160;</td>
          <td class="paramname"><em>n1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a>&#160;</td>
          <td class="paramname"><em>n2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if there is a walkable path from <em>n1</em> to <em>n2</em>. </p>
<p>If you are making changes to the graph, areas must first be recaculated using FloodFill() </p><dl class="section note"><dt>Note</dt><dd>This might return true for small areas even if there is no possible path if <a class="el" href="class_astar_path.html#a341050509352b0ecc8ba1bc5dd75ed36" title="Defines the minimum amount of nodes in an area. ">AstarPath.minAreaSize</a> is greater than zero (0). So when using this, it is recommended to set <a class="el" href="class_astar_path.html#a341050509352b0ecc8ba1bc5dd75ed36" title="Defines the minimum amount of nodes in an area. ">AstarPath.minAreaSize</a> to 0. (A* Inspector -&gt; Settings -&gt; <a class="el" href="namespace_pathfinding.html">Pathfinding</a>) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_astar_path.html#a7d49736e7a25f4cf9fc24bdbec862359" title="Returns the nearest node to a position using the specified NNConstraint. ">AstarPath.GetNearest</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9c65409c2f47489c426cf9b9614e78a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.PathUtilities.IsPathPossible </td>
          <td>(</td>
          <td class="paramtype">List&lt; <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> &gt;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if there are walkable paths between all nodes. </p>
<p>If you are making changes to the graph, areas must first be recaculated using FloodFill() </p><dl class="section note"><dt>Note</dt><dd>This might return true for small areas even if there is no possible path if <a class="el" href="class_astar_path.html#a341050509352b0ecc8ba1bc5dd75ed36" title="Defines the minimum amount of nodes in an area. ">AstarPath.minAreaSize</a> is greater than zero (0). So when using this, it is recommended to set <a class="el" href="class_astar_path.html#a341050509352b0ecc8ba1bc5dd75ed36" title="Defines the minimum amount of nodes in an area. ">AstarPath.minAreaSize</a> to 0. (A* Inspector -&gt; Settings -&gt; <a class="el" href="namespace_pathfinding.html">Pathfinding</a>)</dd></dl>
<p>Returns true for empty lists</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_astar_path.html#a7d49736e7a25f4cf9fc24bdbec862359" title="Returns the nearest node to a position using the specified NNConstraint. ">AstarPath.GetNearest</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aca9c8e2befb7f0e4fe6dcf399a22c66c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Pathfinding.PathUtilities.IsPathPossible </td>
          <td>(</td>
          <td class="paramtype">List&lt; <a class="el" href="class_pathfinding_1_1_graph_node.html">GraphNode</a> &gt;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tagMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns if there are walkable paths between all nodes. </p>
<p>If you are making changes to the graph, areas should first be recaculated using FloodFill()</p>
<p>This method will actually only check if the first node can reach all other nodes. However this is equivalent in 99% of the cases since almost always the graph connections are bidirectional. If you are not aware of any cases where you explicitly create unidirectional connections this method can be used without worries.</p>
<p>Returns true for empty lists</p>
<dl class="section warning"><dt>Warning</dt><dd>This method is significantly slower than the IsPathPossible method which does not take a tagMask</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_astar_path.html#a7d49736e7a25f4cf9fc24bdbec862359" title="Returns the nearest node to a position using the specified NNConstraint. ">AstarPath.GetNearest</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>E:/Andrei/Frostcore/Frostcore/Assets/AstarPathfindingProject/Utilities/<a class="el" href="_path_utilities_8cs.html">PathUtilities.cs</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 18 2016 19:28:56 for Frostcore by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
